---
import { db } from "@/db";
import {
  tablePlinkoGameRounds,
  tablePlinkoGames,
  tableUsers,
} from "@/db/schema";
import { requireNum } from "@/lib/server/parse_int";
import { desc, eq, gt, inArray } from "drizzle-orm";
import { actions } from "astro:actions";
import Layout from "@/layouts/Layout.astro";
import {
  $currentRoundRemoteData,
  $gameRemoteData,
  $leaderboard,
} from "@/lib/stores";
import { allTasks } from "nanostores";
import { Button } from "@/components/ui/button";
import {
  GameOverScoreboard,
  PlinkoScoreboard,
} from "@/components/card/PlinkoScoreboard";
import { LeaderboardTable } from "@/components/table/LeaderboardTable";
import {
  PlinkoGameOverDialog,
  PlinkoRoundEndedDialog,
  PlinkoRoundWaitingToStartDialog,
} from "@/components/dialog/PlinkoRoundDialog";
import { requireAuth } from "@/lib/server/auth_utils";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { PlinkoRoundProgressBar } from "@/components/progress/PlinkoRoundProgressBar";
import { listTopGamesWithUsers } from "@/lib/server/loaders/listTopGamesWithUsers";
import { AuthDialog } from "@/components/dialog/AuthDialog";

const user = requireAuth(Astro);

const { gameId: gameId_ } = Astro.params;

if (!gameId_) throw new Error("No game ID provided");

const gameId = requireNum(gameId_);

await listTopGamesWithUsers();

// TODO: consider batching https://orm.drizzle.team/docs/batch-api

//

// Get the game from the database
const plinkoGameWithRounds = await db
  .select({
    game: tablePlinkoGames, // This will include all columns from the plinkoGames table
    round: tablePlinkoGameRounds, // This includes all columns from the plinkoGameRounds table
  })
  .from(tablePlinkoGames)
  .leftJoin(
    tablePlinkoGameRounds,
    eq(tablePlinkoGames.id, tablePlinkoGameRounds.game_id)
  )
  .where(eq(tablePlinkoGames.id, gameId));

if (plinkoGameWithRounds.length === 0) {
  throw new Error("Game not found");
}

const game = plinkoGameWithRounds[0].game;

const gameRounds = plinkoGameWithRounds.map((row) => row.round).filter(Boolean);

const currentRoundKey = game.current_round_key;
const currentRound = gameRounds.find((round) => round?.key === currentRoundKey);

if (!currentRound) {
  throw new Error("No current round found");
}

// set stores
$currentRoundRemoteData.set(currentRound);
$gameRemoteData.set(game);
---

<script>
  const collisionSound = new Audio("../../src/audio/bubblepop-254773.mp3");
  import Matter from "matter-js";
  import { actions } from "astro:actions";
  import {
    $currentRoundRemoteData,
    $gameRemoteData,
    $nextRoundRemoteData,
    $roundResult,
    $gameState,
    $roundScore,
  } from "@/lib/stores";

  // set up the engine and environment
  const engine = Matter.Engine.create();
  const runner = Matter.Runner.create();

  const matterCanvas: HTMLCanvasElement | null =
    document.querySelector(".matterCanvas");

  if (!matterCanvas) {
    // if the game is over, the canvas is removed on purpose
    if ($gameRemoteData.get()?.game_over) {
      throw new Error("Game is over");
    }

    throw new Error("matterCanvas not found");
  }

  // simulate page scrolling when cursor is over the canvas
  matterCanvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    window.scrollBy(0, e.deltaY);
  });

  const globalSettings = {
    width: matterCanvas.width,
    height: matterCanvas.height,
    pocketKeys: [
      "pocket_middle_left_3",
      "pocket_middle_left_2",
      "pocket_middle_left_1",
      "pocket_middle",
      "pocket_middle_right_1",
      "pocket_middle_right_2",
      "pocket_middle_right_3",
    ],
    // pocketWidth: width / 7, // this number should be the the length of pocketKeys
    pocketHeight: 50,
    pocketDividerHeight: 50,
    ballSize: 10,
  } as const;

  // the current round id
  let currentRoundId: number;
  let roundComposite: Matter.Composite;

  type PocketSettings = Record<
    (typeof globalSettings.pocketKeys)[number],
    { value: number; powerUps: string[] }
  >;

  let pocketSettings: PocketSettings | null;
  let activePlinkoBall: Matter.Body | null;
  let activePlinkoBallIdx: number;
  let plinkoBallsForRound: Matter.Body[];
  let numBallsLeftToDrop: number;
  let currentAlivePlinkos: number;

  // set up the renderer
  const render = Matter.Render.create({
    canvas: matterCanvas,
    engine,
    // set a background slightly lighter than the body's own background
    options: {
      wireframes: false,
      background: "hsl(225, 60%, 20%)",
      width: globalSettings.width,
      height: globalSettings.height,
    },
  });

  const mouse = Matter.Mouse.create(matterCanvas); //Creating the mouse in the world (i.e. Canvas)
  const { world } = engine;

  // From Docs: Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
  const mouseConstraint = Matter.MouseConstraint.create(engine, {
    mouse,
  });

  // function fabricating a plinko, as a circle included atop the canvas
  const makePlinko = ({
    x,
    y,
    size,
    // customImage,
    options = {},
  }: {
    x: number;
    y: number;
    size: number;
    // customImage: string;
    options?: Matter.IBodyDefinition;
  }) => {
    // utility function returning a random integer between two values for color selection
    const randomBetweenForColor = (min: number, max: number) =>
      Math.floor(Math.random() * (max - min)) + min;
    // Plinko Ball Color
    const fillStyle = `hsl(${randomBetweenForColor(0, 360)}, 90%, 60%)`;

    const r = size; //ball size

    return Matter.Bodies.circle(x, y, r, {
      ...options,
      restitution: options.restitution || 0.8,
      render: options.render || {
        fillStyle,
      },
      label: "plinko",
    });
  };

  const hand = Matter.Bodies.rectangle(
    -20,
    10,
    globalSettings.ballSize * 2,
    globalSettings.ballSize * 2,
    {
      isStatic: true,
      collisionFilter: {
        group: -1, // so that the hand does not collide with the plinko balls
      },
      render: {
        sprite: {
          texture: "../../src/images/hand.png",
          xScale: 1.0,
          yScale: 1.0,
        },
      },
      label: "hand",
    }
  );

  Matter.World.add(world, [hand]);

  /********************************************************************************************
   *
   *
   * Create the board
   *
   *
   *******************************************************************************************/
  function initBoard(settings: typeof globalSettings) {
    const pegGrid = {
      pegSize: 10,
      numRows: 13, // this number should be odd
      paddingTop: 50,
      paddingLeft: 0,
      paddingRight: 0,
      paddingBottom: settings.pocketHeight + settings.pocketDividerHeight + 20,
    } as const;

    /******************************************************************************************
     * Create the left and right walls
     *******************************************************************************************/
    const leftWall_ = {
      x: -1,
      y: settings.height / 2,
      width: 1,
      height: settings.height,
    } as const;
    const leftWall = Matter.Bodies.rectangle(
      leftWall_.x,
      leftWall_.y,
      leftWall_.width,
      leftWall_.height,
      {
        isStatic: true,
        label: "leftWall",
        render: {
          fillStyle: "white",
        },
      }
    );

    const rightWall_ = {
      x: settings.width + 1,
      y: settings.height / 2,
      width: 1,
      height: settings.height,
    } as const;
    const rightWall = Matter.Bodies.rectangle(
      rightWall_.x,
      rightWall_.y,
      rightWall_.width,
      rightWall_.height,
      {
        isStatic: true,
        label: "rightWall",
        render: {
          fillStyle: "white",
        },
      }
    );

    /******************************************************************************************
     * Create the triangles on the left and right sides
     *******************************************************************************************/
    let contourLeftTriangles = [];
    let contourRightTriangles = [];

    for (
      let i = pegGrid.paddingTop;
      i < settings.height - pegGrid.paddingBottom;
      i += 50
    ) {
      const leftTriangle_ = {
        x: -30,
        y: i,
        sides: 3,
        radius: 60,
      } as const;
      const leftTriangle = Matter.Bodies.polygon(
        leftTriangle_.x,
        leftTriangle_.y,
        leftTriangle_.sides,
        leftTriangle_.radius,
        {
          isStatic: true,
          angle: Math.PI,
          render: {
            sprite: {
              texture: "../../src/images/icy.png",
              xScale: 0.36, //This is changing the pyramid's altitude (tip tip to floor)
              yScale: 0.9, //This is making the base wider (so they can touch)
            },
          },
        }
      );

      const rightTriangle_ = {
        x: settings.width + 30,
        // x: width + width / 10,
        y: i,
        sides: 3,
        radius: 60,
      } as const;
      const rigttTriangle = Matter.Bodies.polygon(
        rightTriangle_.x,
        rightTriangle_.y,
        rightTriangle_.sides,
        rightTriangle_.radius,
        {
          isStatic: true,
          angle: 2 * Math.PI,
          render: {
            // fillStyle: "white",
            sprite: {
              texture: "../../src/images/icy.png",
              xScale: 0.19, //This is changing the pyramid's altitude (tip tip to floor)
              yScale: 0.5, //This is making the base wider (so they can touch)
            },
          },
        }
      );

      contourLeftTriangles.push(leftTriangle);
      contourRightTriangles.push(rigttTriangle);
    }

    // add the walls, triangles to the world
    Matter.World.add(world, [
      leftWall,
      rightWall,
      ...contourLeftTriangles,
      ...contourRightTriangles,
    ]);

    /******************************************************************************************
     * Create the pegs
     *******************************************************************************************/
    // pegs
    const numPegsInRow = settings.pocketKeys.length - 1;

    const rowSize =
      (settings.height - pegGrid.paddingTop - pegGrid.paddingBottom) /
      pegGrid.numRows;

    const pocketWidth = settings.width / settings.pocketKeys.length;

    const grid = Array.from({ length: pegGrid.numRows }, (_, rowIdx) => {
      // if the row is odd the number of pegs to create is one less than the number of pegs in the row
      const pegsToCreate = rowIdx % 2 === 0 ? numPegsInRow : numPegsInRow - 1;
      // we have to shift the pegs to the right by half the column size
      const xOffset = pegsToCreate !== numPegsInRow ? pocketWidth / 2 : 0;

      return Array.from({ length: pegsToCreate }, (_, pegIdx) => {
        const x = pocketWidth + pocketWidth * pegIdx + xOffset;
        const y = rowSize * rowIdx + rowSize / 2 + pegGrid.paddingTop;
        const r = pegGrid.pegSize / 2;

        return Matter.Bodies.circle(x, y, r, {
          isStatic: true,
          render: { fillStyle: "white" },
          // add a label to later identify the circle in the collision event
          label: "peg",
        });
      });
    });

    // since grid refers to a 2d array, flatten the items to a one-dimensional array
    const pegs = grid.reduce((acc, curr) => [...acc, ...curr], []);

    // add the pegs to the world
    Matter.World.add(world, pegs);
  }

  /******************************************************************************************
   *
   *
   * Create the round
   *
   *
   *******************************************************************************************/
  function initRound(settings: typeof globalSettings) {
    // clear the round result
    $roundResult.set(null);

    // if there is a "next round" set, set the current round to the next round
    // const nextRound = $nextRoundRemoteData.get();

    // if (nextRound) {
    //   $currentRoundRemoteData.set(nextRound);
    //   $nextRoundRemoteData.set(null);
    // }

    const roundData = $currentRoundRemoteData.get();

    if (!roundData) {
      throw new Error("No current round found");
    }

    console.log("initRound: ", roundData.key);

    // set the current round id
    currentRoundId = roundData.id;

    // set the pockets
    const pockets: Matter.Body[] = [];
    const pocketDividers: Matter.Body[] = [];
    pocketSettings = {
      pocket_middle_left_3: {
        value: roundData.pocket_middle_left_3_value,
        powerUps: roundData.pocket_middle_left_3_power_ups,
      },
      pocket_middle_left_2: {
        value: roundData.pocket_middle_left_2_value,
        powerUps: roundData.pocket_middle_left_2_power_ups,
      },
      pocket_middle_left_1: {
        value: roundData.pocket_middle_left_1_value,
        powerUps: roundData.pocket_middle_left_1_power_ups,
      },
      pocket_middle: {
        value: roundData.pocket_middle_value,
        powerUps: roundData.pocket_middle_power_ups,
      },
      pocket_middle_right_1: {
        value: roundData.pocket_middle_right_1_value,
        powerUps: roundData.pocket_middle_right_1_power_ups,
      },
      pocket_middle_right_2: {
        value: roundData.pocket_middle_right_2_value,
        powerUps: roundData.pocket_middle_right_2_power_ups,
      },
      pocket_middle_right_3: {
        value: roundData.pocket_middle_right_3_value,
        powerUps: roundData.pocket_middle_right_3_power_ups,
      },
    };

    // create a new round
    let newRoundComposite = Matter.Composite.create({
      label: "round",
    });

    const pocketWidth = settings.width / settings.pocketKeys.length;

    settings.pocketKeys.forEach((pocketKey, index) => {
      // make pockets
      const pocket_ = {
        x: pocketWidth * index + pocketWidth / 2,
        y: settings.height - settings.pocketHeight / 2,
        width: pocketWidth,
        height: settings.pocketHeight,
      };
      const pocket = Matter.Bodies.rectangle(
        pocket_.x,
        pocket_.y,
        pocket_.width,
        pocket_.height,
        {
          isStatic: true,
          label: pocketKey,
          render: {
            fillStyle: "white",
          },
        }
      );

      pockets.push(pocket);

      // make pocket dividers
      if (index > 0) {
        const pocketDivider_ = {
          x: pocket_.x - pocketWidth / 2,
          y: pocket_.y - pocket_.height + 5,
          width: 5,
          height: settings.pocketDividerHeight,
        };
        const pocketDivider = Matter.Bodies.rectangle(
          pocketDivider_.x,
          pocketDivider_.y,
          pocketDivider_.width,
          pocketDivider_.height,
          {
            isStatic: true,
            render: {
              fillStyle: "white",
            },
          }
        );

        pocketDividers.push(pocketDivider);
      }
    });

    // add the pockets to the composite
    Matter.Composite.add(newRoundComposite, [...pockets, ...pocketDividers]);

    /******************************************************************************************
     * Plinko balls
     *******************************************************************************************/

    plinkoBallsForRound = [];

    // create the plinko balls
    for (let i = 0; i < 5; i++) {
      const plinkoBall = makePlinko({
        x: -20,
        y: 20,
        size: settings.ballSize,
        options: {
          restitution: 0.9,
          // balls should not collide with each other
          collisionFilter: {
            group: -1,
          },
        },
      });
      plinkoBall.isStatic = true;
      plinkoBallsForRound.push(plinkoBall);
    }

    activePlinkoBallIdx = 0;
    activePlinkoBall = plinkoBallsForRound[activePlinkoBallIdx] || null;

    // add the first ball to the world
    if (activePlinkoBall) {
      Matter.Composite.add(newRoundComposite, activePlinkoBall);
    }

    /******************************************************************************************
     *
     ******************************************************************************************/
    // remove the previous round
    if (roundComposite) {
      Matter.World.remove(world, roundComposite);
    }

    // add the composite to the world
    Matter.World.add(world, newRoundComposite);
    roundComposite = newRoundComposite;
  }

  // initialize the board
  initBoard(globalSettings);

  // listen for the round result
  $roundResult.subscribe(async (val) => {
    // reset the local stuff when the round result is set to null
    if (val === null) {
      pocketSettings = null;
      currentAlivePlinkos = 0;
      numBallsLeftToDrop = 5;
      plinkoBallsForRound = [];
      activePlinkoBallIdx = 0;
      activePlinkoBall = null;
      $roundScore.set(0);

      return;
    }

    // if the round result is set, save to the database
    const { data, error } =
      await actions.updatePlinkoRoundScoreAndUpsertNextRound({
        roundId: val.roundId,
        roundScore: val.score,
      });

    if (error) {
      throw new Error("Error updating round score");
    }

    const { updatedRound, nextRound, updatedGame } = data;
    // update the stores
    $currentRoundRemoteData.set(updatedRound);
    $nextRoundRemoteData.set(nextRound);
    $gameRemoteData.set(updatedGame);

    // proceed
    // if there is a next round, set this game state to "round_ended"
    if (nextRound) {
      $gameState.set("round_ended");
    } else {
      // if there is no next round, set the game state to "game_over"
      $gameState.set("game_over");
    }
  });

  // initialize the round
  $currentRoundRemoteData.subscribe((roundData, prev) => {
    if (!roundData) {
      throw new Error("No round data found");
    }

    // if the current round key has changed, reset the round
    if (roundData.key !== prev?.key) {
      initRound(globalSettings);
    }
  });

  /******************************************************************************************
   * Handle collisions
   *******************************************************************************************/
  Matter.Events.on(engine, "collisionStart", (event) => {
    const { pairs } = event;

    let internalScore = 0;

    pairs.forEach((pair) => {
      // get the x position of the plinko and floor collision
      const { bodyA, bodyB } = pair;
      const { label: labelA } = bodyA;
      const { label: labelB } = bodyB;

      // we only care about plinko collisions
      if (labelA !== "plinko" && labelB !== "plinko") {
        return;
      }

      let plinko: Matter.Body;
      let other: Matter.Body;

      if (labelA === "plinko") {
        plinko = bodyA;
        other = bodyB;
      } else {
        plinko = bodyB;
        other = bodyA;
      }

      // if the plinko is colliding with a pocket
      if (other.label in (pocketSettings || {})) {
        // get the pocket in which the plinko has fallen
        // const pocket = pockets.find((pocket) => pocket.label === other.label);
        // console.log("Plinko has fallen into pocket", pocket);
        const pocket_ =
          pocketSettings?.[other.label as keyof typeof pocketSettings];

        if (!pocket_) {
          throw new Error("No pocket found");
        }

        // console.log("Add score: ", pocketSettings.value);
        internalScore += pocket_.value;
        // roundScore += pocket_.value;
        $roundScore.set($roundScore.get() + pocket_.value);

        // remove the plinko from the world
        // World.remove(world, plinko);
        Matter.Composite.remove(roundComposite, plinko);
        currentAlivePlinkos--;

        if (currentAlivePlinkos <= 0) {
          console.log("Round ended");
          // onRoundEnd();
          $roundResult.set({
            score: $roundScore.get(),
            roundId: currentRoundId,
          });
          // console.log("Round score: ", roundScore);
        }

        return;
      }

      // following a collision event retrieve the label of the two bodies
      // if one is a plinko, consider its color and apply it to the other body
      // const { bodyA, bodyB } = pair;
      // const { label: labelA } = bodyA;
      // const { label: labelB } = bodyB;

      // ! change the color only if one of the two body is a plinko
      // if (labelA !== labelB) {
      //   if (labelA === "plinko") {
      //     const { fillStyle } = bodyA.render;
      //     bodyB.render.fillStyle = fillStyle;
      //     collisionSound.play();
      //   }
      //   if (labelB === "plinko") {
      //     const { fillStyle } = bodyB.render;
      //     bodyA.render.fillStyle = fillStyle;
      //     collisionSound.play();
      //   }
      // }
    });

    if (internalScore > 0) {
      collisionSound.play();
    }
  });

  /******************************************************************************************
   * Handle mouse movement
   ******************************************************************************************/
  Matter.Events.on(mouseConstraint, "mousemove", (event) => {
    // set the hand position
    Matter.Body.setPosition(hand, {
      x: mouse.position.x,
      y: 10,
    });

    if (!activePlinkoBall) return;

    // the next ball to be dropped should follow the mouse
    Matter.Body.setPosition(activePlinkoBall, {
      x: mouse.position.x,
      // preserve the y position of the ball
      y: activePlinkoBall.position.y,
    });
  });

  /******************************************************************************************
   * Handle mouse up (click)
   ******************************************************************************************/
  Matter.Events.on(mouseConstraint, "mouseup", (event) => {
    if (numBallsLeftToDrop <= 0) {
      console.log("No more balls remaining");
      return;
    }

    // if there is an active ball, drop it
    if (activePlinkoBall) {
      Matter.Body.setStatic(activePlinkoBall, false);
      activePlinkoBallIdx++;
      activePlinkoBall = plinkoBallsForRound[activePlinkoBallIdx];
      // add the next ball to the world
      if (activePlinkoBall) {
        Matter.Body.setPosition(activePlinkoBall, {
          x: mouse.position.x,
          y: 20,
        });
        Matter.Composite.add(roundComposite, activePlinkoBall);
      }

      currentAlivePlinkos++;
      numBallsLeftToDrop--;
    }
  });

  // run the engine
  Matter.Runner.run(runner, engine); //We have eto create and run the runner so that the engine start playing the annimation.
  // run the renderer
  Matter.Render.run(render);
</script>

<Layout title="Let's play Christmas Plinko! by The Adpharm">
  <main class="flex flex-col min-h-screen pt-32">
    <div class="max-w-4xl mx-auto p-4 w-full">
      <Breadcrumb>
        <BreadcrumbList>
          <BreadcrumbItem>
            <BreadcrumbLink href="/digital/plinko">Games</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbSeparator />
          <BreadcrumbItem>
            <BreadcrumbPage>This game</BreadcrumbPage>
          </BreadcrumbItem>
        </BreadcrumbList>
      </Breadcrumb>
    </div>
    <div class="max-w-4xl mx-auto p-4 w-full">
      <PlinkoRoundProgressBar client:load />
    </div>
    <div class="flex-1 max-w-xl mx-auto p-4">
      {
        game.game_over ? (
          <div>
            <GameOverScoreboard client:load />
          </div>
        ) : (
          <>
            <PlinkoScoreboard client:load />
            <div>
              <canvas
                class="matterCanvas bg-blue-950"
                width={400}
                height={600}
              />
            </div>
            <div class="grid grid-cols-7 text-center">
              <div>{currentRound.pocket_middle_left_3_value}</div>
              <div>{currentRound.pocket_middle_left_2_value}</div>
              <div>{currentRound.pocket_middle_left_1_value}</div>
              <div>{currentRound.pocket_middle_value}</div>
              <div>{currentRound.pocket_middle_right_1_value}</div>
              <div>{currentRound.pocket_middle_right_2_value}</div>
              <div>{currentRound.pocket_middle_right_3_value}</div>
            </div>
          </>
        )
      }
    </div>

    <div class="max-w-4xl mx-auto p-4 w-full">
      <div>
        <LeaderboardTable client:only="react" user={user} />
      </div>
    </div>
  </main>
</Layout>

<!-- dialogs -->
<PlinkoRoundEndedDialog client:load />
<PlinkoRoundWaitingToStartDialog client:load />
<PlinkoGameOverDialog client:load />
<AuthDialog
  client:load
  open={Astro.locals.user === null || Astro.locals.session === null}
/>
