---
import { db } from "@/db";
import {
  tablePlinkoGameRounds,
  tablePlinkoGames,
  tableUsers,
} from "@/db/schema";
import { requireNum } from "@/lib/server/parse_int";
import { desc, eq, gt, inArray } from "drizzle-orm";
import {
  $currentRoundRemoteData,
  $gameRemoteData,
  $leaderboard,
} from "@/lib/stores";
import { allTasks } from "nanostores";
import { Button } from "@/components/ui/button";
import {
  GameOverScoreboard,
  PlinkoScoreboard,
} from "@/components/card/PlinkoScoreboard";
import { LeaderboardTable } from "@/components/table/LeaderboardTable";
import {
  PlinkoGameOverDialog,
  PlinkoRoundEndedDialog,
  PlinkoRoundWaitingToStartDialog,
} from "@/components/dialog/PlinkoRoundDialog";
import { PlinkoRoundProgressBar } from "@/components/progress/PlinkoRoundProgressBar";
import { listTopGamesWithUsers } from "@/lib/server/loaders/listTopGamesWithUsers";
import { getUser } from "@/lib/server/auth.utils";
import { getPagePath } from "@nanostores/router";
import { $router } from "@/lib/stores/router";
import GamesLayout from "@/components/layout/GamesLayout.astro";
import { plinkoSettings } from "@/lib/settings.plinko";
import { PlinkoPocketValueGrid } from "@/components/misc/PlinkoPocketValueGrid";

const user = getUser(Astro);

if (!user) {
  return Astro.redirect(getPagePath($router, "login"));
}

const { gameId: gameId_ } = Astro.params;

if (!gameId_) throw new Error("No game ID provided");

const gameId = requireNum(gameId_);

await listTopGamesWithUsers();

// TODO: consider batching https://orm.drizzle.team/docs/batch-api

//

// Get the game from the database
const plinkoGameWithRounds = await db
  .select({
    game: tablePlinkoGames, // This will include all columns from the plinkoGames table
    round: tablePlinkoGameRounds, // This includes all columns from the plinkoGameRounds table
  })
  .from(tablePlinkoGames)
  .leftJoin(
    tablePlinkoGameRounds,
    eq(tablePlinkoGames.id, tablePlinkoGameRounds.game_id)
  )
  .where(eq(tablePlinkoGames.id, gameId));

if (plinkoGameWithRounds.length === 0) {
  throw new Error("Game not found");
}

const game = plinkoGameWithRounds[0].game;

const gameRounds = plinkoGameWithRounds.map((row) => row.round).filter(Boolean);

const currentRoundKey = game.current_round_key;
const currentRound = gameRounds.find((round) => round?.key === currentRoundKey);

if (!currentRound) {
  throw new Error("No current round found");
}

// set stores
$currentRoundRemoteData.set(currentRound);
$gameRemoteData.set(game);
---

<script>
  const collisionSound = new Audio("/plinko/audio/bubblepop-254773.mp3");
  import Matter from "matter-js";
  import { actions } from "astro:actions";
  import { tablePlinkoGameRounds } from "@/db/schema";
  import {
    $currentRoundRemoteData,
    $gameRemoteData,
    $nextRoundRemoteData,
    $roundResult,
    $gameState,
    $roundScore,
    $remainingPlinkoBallsThisRound,
    type PlinkoBallData,
  } from "@/lib/stores";
  import { toast } from "sonner";
  import { logDebug, logError, logInfo } from "@/lib/utils.logger";
  import { DotLottie, DotLottieWorker } from "@lottiefiles/dotlottie-web";
  import { plinkoSettings } from "@/lib/settings.plinko";

  const matterCanvas: HTMLCanvasElement | null =
    document.querySelector(".matterCanvas");

  if (!matterCanvas) {
    // if the game is over, the canvas is removed on purpose
    if ($gameRemoteData.get()?.game_over) {
      throw new Error("Game is over");
    }

    throw new Error("matterCanvas not found");
  }

  // simulate page scrolling when cursor is over the canvas
  matterCanvas.addEventListener(
    "wheel",
    (e) => {
      // e.preventDefault(); // can't use with passive: true
      window.scrollBy(0, e.deltaY);
    },
    { passive: true }
  );

  const matterCanvasOverlay: HTMLCanvasElement | null = document.querySelector(
    ".matterCanvasOverlay"
  );
  const matterCanvasOverlayCtx = matterCanvasOverlay?.getContext("2d");

  if (!matterCanvasOverlay || !matterCanvasOverlayCtx) {
    throw new Error("matterCanvasOverlay not found");
  }

  const pocketLottieCanvases: (HTMLCanvasElement | null)[] = Array.from(
    document.querySelectorAll(
      ".pocket-lottie-canvas"
    ) as NodeListOf<HTMLCanvasElement>
  );

  if (
    pocketLottieCanvases.length === 0 ||
    pocketLottieCanvases.some((canvas) => !canvas)
  ) {
    throw new Error("At least one DotLottie canvas was not found");
  }

  const imagesToLoad = [
    "/plinko/textures/hand.png",
    "/plinko/textures/icy.png",
  ];

  logDebug("preloading images");
  await Promise.all(
    imagesToLoad.map((src) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = resolve;
        img.onerror = reject;
        img.src = src;
      });
    })
  );
  logDebug("images preloaded");

  const pocketLottieAnimations: Record<
    (typeof plinkoSettings.pocketKeys)[number],
    DotLottieWorker
    // DotLottie
  > = {
    pocket_middle_left_3: new DotLottieWorker({
      canvas: pocketLottieCanvases[0]!,
      src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie",
    }),
    pocket_middle_left_2: new DotLottieWorker({
      canvas: pocketLottieCanvases[1]!,
      src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie",
    }),
    pocket_middle_left_1: new DotLottieWorker({
      canvas: pocketLottieCanvases[2]!,
      src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie",
    }),
    pocket_middle: new DotLottieWorker({
      canvas: pocketLottieCanvases[3]!,
      src: "https://lottie.host/0cbdb3ef-2fa5-4d1d-9e4e-f66c879e010d/D0bRr9d93F.lottie",
    }),
    pocket_middle_right_1: new DotLottieWorker({
      canvas: pocketLottieCanvases[4]!,
      src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie",
    }),
    pocket_middle_right_2: new DotLottieWorker({
      canvas: pocketLottieCanvases[5]!,
      src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie",
    }),
    pocket_middle_right_3: new DotLottieWorker({
      canvas: pocketLottieCanvases[6]!,
      src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie",
    }),
  };

  // const dotLottie = new DotLottie({
  //   canvas: dotLottieCanvas,
  //   // src: "https://lottie.host/4db68bbd-31f6-4cd8-84eb-189de081159a/IGmMCqhzpt.lottie", // or .json file
  //   src: "https://lottie.host/ddc1847b-5563-45dd-806c-c124252ce2ea/BZ8KuBgUWM.lottie",
  // });

  // set up the engine and environment
  const engine = Matter.Engine.create();
  const runner = Matter.Runner.create();

  // the current round id
  let currentRoundId: number;
  let currentRoundScoreMultiplier: number;
  let roundComposite: Matter.Composite;

  let pocketsToCreate: Record<
    (typeof plinkoSettings.pocketKeys)[number],
    {
      value: typeof tablePlinkoGameRounds.$inferSelect.pocket_middle_value;
      powerUps: typeof tablePlinkoGameRounds.$inferSelect.pocket_middle_power_ups;
    }
  > | null;
  let plinkoBallsToCreate: Record<
    (typeof plinkoSettings.plinkoBallKeys)[number],
    {
      on: typeof tablePlinkoGameRounds.$inferSelect.plinko_ball_10_on;
      powerUps: typeof tablePlinkoGameRounds.$inferSelect.plinko_ball_10_power_ups;
    }
  > | null;
  let activePlinkoBall: Matter.Body | null;
  let activePlinkoBallIdx: number;
  let currentRoundPlinkoBallBodies: Matter.Body[];
  let currentAlivePlinkos: number;

  // set up the renderer
  const render = Matter.Render.create({
    canvas: matterCanvas,
    engine,
    // set a background slightly lighter than the body's own background
    options: {
      wireframes: false, // must be false in deployment
      // background: "hsl(225, 60%, 20%)",
      background: "transparent",
      width: plinkoSettings.canvasWidth,
      height: plinkoSettings.canvasHeight,
    },
  });

  const mouse = Matter.Mouse.create(matterCanvas); //Creating the mouse in the world (i.e. Canvas)
  const { world } = engine;

  // From Docs: Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
  const mouseConstraint = Matter.MouseConstraint.create(engine, {
    mouse,
  });

  // function fabricating a plinko, as a circle included atop the canvas
  const makePlinko = ({
    x,
    y,
    size,
    // customImage,
    options = {},
  }: {
    x: number;
    y: number;
    size: number;
    // customImage: string;
    options: Matter.IBodyDefinition;
  }) => {
    if (!options.label) {
      throw new Error("You should provide a label for the plinko");
    }

    // utility function returning a random integer between two values for color selection
    const randomBetweenForColor = (min: number, max: number) =>
      Math.floor(Math.random() * (max - min)) + min;
    // Plinko Ball Color
    const fillStyle = `hsl(${randomBetweenForColor(0, 360)}, 90%, 60%)`;

    const r = size; //ball size

    return Matter.Bodies.circle(x, y, r, {
      ...options,
      restitution: options.restitution || 0.8,
      render: options.render || {
        fillStyle,
      },
    });
  };

  const hand = Matter.Bodies.rectangle(
    -20,
    10,
    plinkoSettings.ballSize * 2,
    plinkoSettings.ballSize * 2,
    {
      isStatic: true,
      collisionFilter: {
        group: -1, // so that the hand does not collide with the plinko balls
      },
      render: {
        sprite: {
          texture: "/plinko/textures/hand.png",
          xScale: 1.0,
          yScale: 1.0,
        },
      },
      label: "hand",
    }
  );

  Matter.World.add(world, [hand]);

  /********************************************************************************************
   *
   *
   * Create the board
   *
   *
   *******************************************************************************************/
  function initBoard(settings: typeof plinkoSettings) {
    const pegGrid = {
      pegSize: 10,
      numRows: 13, // this number should be odd
      paddingTop: 50,
      paddingLeft: 0,
      paddingRight: 0,
      paddingBottom: settings.pocketHeight + settings.pocketDividerHeight + 20,
    } as const;

    /******************************************************************************************
     * Create the left and right walls
     *******************************************************************************************/
    const leftWall_ = {
      x: -1,
      y: settings.canvasHeight / 2,
      width: 1,
      height: settings.canvasHeight,
    } as const;
    const leftWall = Matter.Bodies.rectangle(
      leftWall_.x,
      leftWall_.y,
      leftWall_.width,
      leftWall_.height,
      {
        isStatic: true,
        label: "leftWall",
        render: {
          fillStyle: "white",
        },
      }
    );

    const rightWall_ = {
      x: settings.canvasWidth + 1,
      y: settings.canvasHeight / 2,
      width: 1,
      height: settings.canvasHeight,
    } as const;
    const rightWall = Matter.Bodies.rectangle(
      rightWall_.x,
      rightWall_.y,
      rightWall_.width,
      rightWall_.height,
      {
        isStatic: true,
        label: "rightWall",
        render: {
          fillStyle: "white",
        },
      }
    );

    /******************************************************************************************
     * Create the triangles on the left and right sides
     *******************************************************************************************/
    let contourLeftTriangles = [];
    let contourRightTriangles = [];

    for (
      let i = pegGrid.paddingTop;
      i < settings.canvasHeight - pegGrid.paddingBottom;
      i += 50
    ) {
      const leftTriangle_ = {
        x: -30,
        y: i,
        sides: 3,
        radius: 60,
      } as const;
      const leftTriangle = Matter.Bodies.polygon(
        leftTriangle_.x,
        leftTriangle_.y,
        leftTriangle_.sides,
        leftTriangle_.radius,
        {
          isStatic: true,
          angle: Math.PI,
          render: {
            sprite: {
              texture: "/plinko/textures/icy.png",
              xScale: 0.36, //This is changing the pyramid's altitude (tip tip to floor)
              yScale: 0.9, //This is making the base wider (so they can touch)
            },
          },
        }
      );

      const rightTriangle_ = {
        x: settings.canvasWidth + 30,
        // x: width + width / 10,
        y: i,
        sides: 3,
        radius: 60,
      } as const;
      const rigttTriangle = Matter.Bodies.polygon(
        rightTriangle_.x,
        rightTriangle_.y,
        rightTriangle_.sides,
        rightTriangle_.radius,
        {
          isStatic: true,
          angle: 2 * Math.PI,
          render: {
            // fillStyle: "white",
            sprite: {
              texture: "/plinko/textures/icy.png",
              xScale: 0.19, //This is changing the pyramid's altitude (tip tip to floor)
              yScale: 0.5, //This is making the base wider (so they can touch)
            },
          },
        }
      );

      contourLeftTriangles.push(leftTriangle);
      contourRightTriangles.push(rigttTriangle);
    }

    // add the walls, triangles to the world
    Matter.World.add(world, [
      leftWall,
      rightWall,
      ...contourLeftTriangles,
      ...contourRightTriangles,
    ]);

    /******************************************************************************************
     * Create the pegs
     *******************************************************************************************/
    // pegs
    const numPegsInRow = settings.pocketKeys.length - 1;

    const rowSize =
      (settings.canvasHeight - pegGrid.paddingTop - pegGrid.paddingBottom) /
      pegGrid.numRows;

    const pocketWidth = settings.canvasWidth / settings.pocketKeys.length;

    const grid = Array.from({ length: pegGrid.numRows }, (_, rowIdx) => {
      // if the row is odd the number of pegs to create is one less than the number of pegs in the row
      const pegsToCreate = rowIdx % 2 === 0 ? numPegsInRow : numPegsInRow - 1;
      // we have to shift the pegs to the right by half the column size
      const xOffset = pegsToCreate !== numPegsInRow ? pocketWidth / 2 : 0;

      return Array.from({ length: pegsToCreate }, (_, pegIdx) => {
        const x = pocketWidth + pocketWidth * pegIdx + xOffset;
        const y = rowSize * rowIdx + rowSize / 2 + pegGrid.paddingTop;
        const r = pegGrid.pegSize / 2;

        // create the peg
        return Matter.Bodies.circle(x, y, r, {
          isStatic: true,
          render: { fillStyle: "white" },
          // add a label to later identify the circle in the collision event
          label: "peg",
        });
      });
    });

    // since grid refers to a 2d array, flatten the items to a one-dimensional array
    const pegs = grid.reduce((acc, curr) => [...acc, ...curr], []);

    // add the pegs to the world
    Matter.World.add(world, pegs);
  }

  /******************************************************************************************
   *
   *
   * Create the round
   *
   *
   *******************************************************************************************/
  function initRound(settings: typeof plinkoSettings) {
    // clear the round result
    $roundResult.set(null);

    // if the game is over, stop everything
    if ($gameState.get() === "game_over") {
      logInfo("Game is over, stopping the game");
      // remove all listeners
      Matter.Events.off(engine, "collisionStart");
      Matter.Events.off(mouseConstraint, "mousemove");
      Matter.Events.off(mouseConstraint, "mouseup");
      Matter.Events.off(runner, "afterTick");

      // stop the engine
      Matter.Runner.stop(runner);
      Matter.Render.stop(render);
    }

    const roundData = $currentRoundRemoteData.get();

    if (!roundData) {
      throw new Error("No current round found");
    }

    logDebug("initRound: ", roundData.key);

    // set the current round id
    currentRoundId = roundData.id;
    currentRoundScoreMultiplier = roundData.score_multiplier;

    // set the pockets
    const pockets: Matter.Body[] = [];
    const pocketDividers: Matter.Body[] = [];
    //
    pocketsToCreate = {
      pocket_middle_left_3: {
        value: roundData.pocket_middle_left_3_value,
        powerUps: roundData.pocket_middle_left_3_power_ups,
      },
      pocket_middle_left_2: {
        value: roundData.pocket_middle_left_2_value,
        powerUps: roundData.pocket_middle_left_2_power_ups,
      },
      pocket_middle_left_1: {
        value: roundData.pocket_middle_left_1_value,
        powerUps: roundData.pocket_middle_left_1_power_ups,
      },
      pocket_middle: {
        value: roundData.pocket_middle_value,
        powerUps: roundData.pocket_middle_power_ups,
      },
      pocket_middle_right_1: {
        value: roundData.pocket_middle_right_1_value,
        powerUps: roundData.pocket_middle_right_1_power_ups,
      },
      pocket_middle_right_2: {
        value: roundData.pocket_middle_right_2_value,
        powerUps: roundData.pocket_middle_right_2_power_ups,
      },
      pocket_middle_right_3: {
        value: roundData.pocket_middle_right_3_value,
        powerUps: roundData.pocket_middle_right_3_power_ups,
      },
    };

    // create a new round
    let newRoundComposite = Matter.Composite.create({
      label: "round",
    });

    const pocketWidth = settings.canvasWidth / settings.pocketKeys.length;

    settings.pocketKeys.forEach((pocketKey, index) => {
      // make pockets
      const pocket_ = {
        x: pocketWidth * index + pocketWidth / 2,
        y: settings.canvasHeight - settings.pocketHeight / 2,
        width: pocketWidth,
        height: settings.pocketHeight,
      };
      const pocket = Matter.Bodies.rectangle(
        pocket_.x,
        pocket_.y,
        pocket_.width,
        pocket_.height,
        {
          isStatic: true,
          label: pocketKey,
          render: {
            fillStyle: "white",
          },
        }
      );

      pockets.push(pocket);

      // make pocket dividers
      if (index > 0) {
        const pocketDivider_ = {
          x: pocket_.x - pocketWidth / 2,
          y: pocket_.y - pocket_.height + 5,
          width: 5,
          height: settings.pocketDividerHeight,
        };
        const pocketDivider = Matter.Bodies.rectangle(
          pocketDivider_.x,
          pocketDivider_.y,
          pocketDivider_.width,
          pocketDivider_.height,
          {
            isStatic: true,
            render: {
              fillStyle: "white",
            },
          }
        );

        pocketDividers.push(pocketDivider);
      }
    });

    // add the pockets to the composite
    Matter.Composite.add(newRoundComposite, [...pockets, ...pocketDividers]);

    /******************************************************************************************
     * Plinko balls
     *******************************************************************************************/

    currentRoundPlinkoBallBodies = [];

    // set up the plinko balls
    plinkoBallsToCreate = {
      plinko_ball_1: {
        on: roundData.plinko_ball_1_on,
        powerUps: roundData.plinko_ball_1_power_ups,
      },
      plinko_ball_2: {
        on: roundData.plinko_ball_2_on,
        powerUps: roundData.plinko_ball_2_power_ups,
      },
      plinko_ball_3: {
        on: roundData.plinko_ball_3_on,
        powerUps: roundData.plinko_ball_3_power_ups,
      },
      plinko_ball_4: {
        on: roundData.plinko_ball_4_on,
        powerUps: roundData.plinko_ball_4_power_ups,
      },
      plinko_ball_5: {
        on: roundData.plinko_ball_5_on,
        powerUps: roundData.plinko_ball_5_power_ups,
      },
      plinko_ball_6: {
        on: roundData.plinko_ball_6_on,
        powerUps: roundData.plinko_ball_6_power_ups,
      },
      plinko_ball_7: {
        on: roundData.plinko_ball_7_on,
        powerUps: roundData.plinko_ball_7_power_ups,
      },
      plinko_ball_8: {
        on: roundData.plinko_ball_8_on,
        powerUps: roundData.plinko_ball_8_power_ups,
      },
      plinko_ball_9: {
        on: roundData.plinko_ball_9_on,
        powerUps: roundData.plinko_ball_9_power_ups,
      },
      plinko_ball_10: {
        on: roundData.plinko_ball_10_on,
        powerUps: roundData.plinko_ball_10_power_ups,
      },
    };

    const remainingPlinkoBallsThisRound: PlinkoBallData[] = [];

    // create the plinko balls
    Object.entries(plinkoBallsToCreate).forEach(
      ([plinkoBallKey_, plinkoBallData]) => {
        const plinkoBallKey =
          plinkoBallKey_ as (typeof plinkoSettings.plinkoBallKeys)[number];
        // if the plinko ball is not on, skip
        if (plinkoBallData.on === false) {
          return;
        }

        // otherwise, create the plinko ball and add it to the plinko balls for the round
        const plinkoBall = makePlinko({
          x: -20,
          y: 20,
          size: settings.ballSize,
          options: {
            restitution: 0.9,
            // balls should not collide with each other
            collisionFilter: {
              group: -1,
            },
            label: plinkoBallKey,
          },
        });
        plinkoBall.isStatic = true;
        currentRoundPlinkoBallBodies.push(plinkoBall);

        remainingPlinkoBallsThisRound.push({
          powerUps: plinkoBallData.powerUps,
          key: plinkoBallKey,
        });
      }
    );

    // set the number of plinko balls remaining to store
    $remainingPlinkoBallsThisRound.set(remainingPlinkoBallsThisRound);

    activePlinkoBallIdx = 0;
    activePlinkoBall =
      currentRoundPlinkoBallBodies[activePlinkoBallIdx] || null;

    // add the first ball to the world
    if (activePlinkoBall) {
      Matter.Composite.add(newRoundComposite, activePlinkoBall);
    }

    /******************************************************************************************
     *
     ******************************************************************************************/
    // remove the previous round
    if (roundComposite) {
      Matter.World.remove(world, roundComposite);
    }

    // add the composite to the world
    Matter.World.add(world, newRoundComposite);
    roundComposite = newRoundComposite;
  }

  // initialize the board
  initBoard(plinkoSettings);

  // listen for the round result
  $roundResult.subscribe(async (val) => {
    // reset the local stuff when the round result is set to null
    if (val === null) {
      logDebug("resetRound");

      pocketsToCreate = null;
      plinkoBallsToCreate = null;
      currentRoundPlinkoBallBodies = [];
      currentAlivePlinkos = 0;
      $remainingPlinkoBallsThisRound.set([]);
      activePlinkoBallIdx = 0;
      activePlinkoBall = null;
      $roundScore.set(0);

      return;
    }

    // if the round result is set, save to the database
    const { data, error } = await actions.plinko.updateScoreAndCreateNextRound({
      roundId: val.roundId,
      roundScore: val.score,
    });

    if (error) {
      logError(error);

      toast.error(`Sorry, an error occured: ${error.message}`, {
        duration: 8000,
      });

      throw new Error();
    }

    const { updatedRound, nextRound, updatedGame } = data;
    // update the stores
    $currentRoundRemoteData.set(updatedRound);
    $nextRoundRemoteData.set(nextRound);
    $gameRemoteData.set(updatedGame);

    // proceed
    // if there is a next round, set this game state to "round_ended"
    if (nextRound) {
      $gameState.set("round_ended");
    } else {
      // if there is no next round, set the game state to "game_over"
      $gameState.set("game_over");
    }
  });

  // initialize the round
  $currentRoundRemoteData.subscribe((roundData, prev) => {
    if (!roundData) {
      throw new Error("No round data found");
    }

    initRound(plinkoSettings);
  });

  let floatingTexts: {
    text: string;
    style: "peg" | "peg-double-points" | "pocket" | "pocket-double-points";
    x: number;
    y: number;
    startTime: number;
    duration: number;
  }[] = [];

  /******************************************************************************************
   * Handle collisions
   *******************************************************************************************/
  Matter.Events.on(engine, "collisionStart", (event) => {
    const { pairs } = event;

    let internalScore = 0;

    pairs.forEach((pair) => {
      // get the x position of the plinko and floor collision
      const { bodyA, bodyB } = pair;
      const { label: labelA } = bodyA;
      const { label: labelB } = bodyB;

      // we only care about plinko collisions
      if (
        plinkoSettings.plinkoBallKeys.includes(labelA as any) === false &&
        plinkoSettings.plinkoBallKeys.includes(labelB as any) === false
      ) {
        return;
      }

      // figure out which body is the plinko
      let plinkoBody: Matter.Body;
      let otherBody: Matter.Body;
      if (plinkoSettings.plinkoBallKeys.includes(labelA as any)) {
        // bodyA is the plinko
        plinkoBody = bodyA;
        otherBody = bodyB;
      } else {
        // bodyB is the plinko
        plinkoBody = bodyB;
        otherBody = bodyA;
      }

      /******************************************************************************************
       *
       * Plinko <-> Pocket collision
       *
       *******************************************************************************************/
      if (otherBody.label in (pocketsToCreate || {})) {
        // get the pocket in which the plinko has fallen
        // const pocket = pockets.find((pocket) => pocket.label === other.label);
        // console.log("Plinko has fallen into pocket", pocket);
        const pocketKey =
          otherBody.label as (typeof plinkoSettings.pocketKeys)[number];
        const pocket_ = pocketsToCreate?.[pocketKey];

        if (!pocket_) {
          toast.error("Something went wrong: No pocket found");
          throw new Error("No pocket found");
        }

        const plinko_ =
          plinkoBallsToCreate?.[
            plinkoBody.label as keyof typeof plinkoBallsToCreate
          ];
        const isGoldenPlinko = plinko_?.powerUps.includes("golden");
        const pocketValue = isGoldenPlinko ? pocket_.value * 2 : pocket_.value;

        // add floating text, if score is greater than 0
        if (pocketValue > 0) {
          floatingTexts.push({
            text: `+${pocketValue}`,
            style: isGoldenPlinko ? "pocket-double-points" : "pocket",
            x:
              pocketKey === "pocket_middle_right_3"
                ? otherBody.position.x - 40 // give it some space so it doesn't go off the canvas
                : otherBody.position.x,
            y: otherBody.position.y - 40,
            startTime: performance.now(),
            duration: 1000,
          });
        }

        // play the lottie animation
        const animation = pocketLottieAnimations[pocketKey];
        animation.play();

        // hide the animation after it finishes
        animation.addEventListener("complete", function onComplete() {
          // Hide or remove the animation after it finishes
          // dotLottieCanvas.style.opacity = "0";
          (animation.canvas as HTMLCanvasElement).style.opacity = "0";
          animation.removeEventListener("complete", onComplete);
        });

        // show the animation
        (animation.canvas as HTMLCanvasElement).style.opacity = "1";

        internalScore += pocket_.value;
        $roundScore.set($roundScore.get() + pocket_.value);

        // remove the plinko from the world
        // World.remove(world, plinko);
        Matter.Composite.remove(roundComposite, plinkoBody);
        currentAlivePlinkos--;

        /**
         * TRIGGER ROUND END
         */
        if (
          currentAlivePlinkos <= 0 &&
          $remainingPlinkoBallsThisRound.get().length === 0
        ) {
          logInfo("Round end");

          $roundResult.set({
            score: $roundScore.get() * currentRoundScoreMultiplier,
            roundId: currentRoundId,
            scoreMultiplier: currentRoundScoreMultiplier,
          });
        }

        return;
      }

      /******************************************************************************************
       *
       * Plinko <-> Peg collision
       *
       *******************************************************************************************/
      if (otherBody.label.includes("peg")) {
        const plinko_ =
          plinkoBallsToCreate?.[
            plinkoBody.label as keyof typeof plinkoBallsToCreate
          ];

        const isGoldenPlinko = plinko_?.powerUps.includes("golden");

        const pegScore = isGoldenPlinko
          ? plinkoSettings.pegScore * 2
          : plinkoSettings.pegScore;

        // add floating text
        floatingTexts.push({
          text: `+${pegScore}`,
          style: isGoldenPlinko ? "peg-double-points" : "peg",
          x: otherBody.position.x,
          y: otherBody.position.y,
          startTime: performance.now(),
          duration: 1000,
        });

        // add the score
        internalScore += pegScore;
        $roundScore.set($roundScore.get() + pegScore);

        return;
      }

      // following a collision event retrieve the label of the two bodies
      // if one is a plinko, consider its color and apply it to the other body
      // const { bodyA, bodyB } = pair;
      // const { label: labelA } = bodyA;
      // const { label: labelB } = bodyB;

      // ! change the color only if one of the two body is a plinko
      // if (labelA !== labelB) {
      //   if (labelA === "plinko") {
      //     const { fillStyle } = bodyA.render;
      //     bodyB.render.fillStyle = fillStyle;
      //     collisionSound.play();
      //   }
      //   if (labelB === "plinko") {
      //     const { fillStyle } = bodyB.render;
      //     bodyA.render.fillStyle = fillStyle;
      //     collisionSound.play();
      //   }
      // }
    });

    if (internalScore > 0) {
      collisionSound.play();
    }
  });

  /******************************************************************************************
   * Handle mouse movement
   ******************************************************************************************/
  Matter.Events.on(mouseConstraint, "mousemove", (event) => {
    // set the hand position
    Matter.Body.setPosition(hand, {
      x: mouse.position.x,
      y: 10,
    });

    if (!activePlinkoBall) return;

    // the next ball to be dropped should follow the mouse
    Matter.Body.setPosition(activePlinkoBall, {
      x: mouse.position.x,
      // preserve the y position of the ball
      y: activePlinkoBall.position.y,
    });
  });

  /******************************************************************************************
   * Handle mouse up (click)
   ******************************************************************************************/
  Matter.Events.on(mouseConstraint, "mouseup", (event) => {
    if ($remainingPlinkoBallsThisRound.get().length === 0) {
      console.log("No more balls remaining");
      return;
    }

    // if there is an active ball, drop it
    if (activePlinkoBall) {
      Matter.Body.setStatic(activePlinkoBall, false);
      activePlinkoBallIdx++;
      activePlinkoBall = currentRoundPlinkoBallBodies[activePlinkoBallIdx];
      // add the next ball to the world
      if (activePlinkoBall) {
        Matter.Body.setPosition(activePlinkoBall, {
          x: mouse.position.x,
          y: 20,
        });
        Matter.Composite.add(roundComposite, activePlinkoBall);
      }

      currentAlivePlinkos++;

      // remove the ball from the remaining balls
      $remainingPlinkoBallsThisRound.set(
        $remainingPlinkoBallsThisRound.get().slice(1)
      );
    }
  });

  Matter.Events.on(runner, "afterTick", (event) => {
    // logDebug("tick");
    // TODO: not sure if I can do this or not
    if (floatingTexts.length === 0) {
      return;
    }

    // clear the canvas
    matterCanvasOverlayCtx.clearRect(
      0,
      0,
      plinkoSettings.canvasWidth,
      plinkoSettings.canvasHeight
    );

    const now = performance.now();

    floatingTexts = floatingTexts.filter((obj) => {
      const elapsed = now - obj.startTime;
      if (elapsed > obj.duration) {
        // Time is up, this text will no longer be drawn
        return false;
      }

      // Calculate alpha (1 at start, 0 at end)
      const alpha = 1 - elapsed / obj.duration;

      // Calculate y position (we want it to move up)
      const y = obj.y - 0.03 * elapsed;

      // Draw the text with fading alpha
      matterCanvasOverlayCtx.save();

      const whiteFill = `rgba(255, 255, 255, ${alpha})`;
      const yellowFill = `rgba(255, 215, 0, ${alpha})`;

      if (obj.style === "peg" || obj.style === "peg-double-points") {
        // peg text style
        matterCanvasOverlayCtx.font = "20px Arial";
        matterCanvasOverlayCtx.fillStyle = whiteFill;
      } else {
        // pocket text style
        matterCanvasOverlayCtx.font = "bold 28px Arial";
        // make text gold with an orange-ish outline
        matterCanvasOverlayCtx.fillStyle = yellowFill;
        matterCanvasOverlayCtx.strokeStyle = `rgba(255, 165, 0, ${alpha})`;
        matterCanvasOverlayCtx.lineWidth = 1;
        matterCanvasOverlayCtx.strokeText(obj.text, obj.x, y);
      }

      if (
        obj.style === "peg-double-points" ||
        obj.style === "pocket-double-points"
      ) {
        matterCanvasOverlayCtx.fillStyle = yellowFill;
      }

      // draw the text
      matterCanvasOverlayCtx.fillText(obj.text, obj.x, y);
      matterCanvasOverlayCtx.restore();

      return true; // Keep this text in the array until it expires
    });
  });

  // run the engine
  Matter.Runner.run(runner, engine); //We have eto create and run the runner so that the engine start playing the annimation.
  // run the renderer
  Matter.Render.run(render);
</script>

<GamesLayout
  title="Good luck in your Christmas Plinko game!"
  breadcrumbs={[
    { name: "Plinko home", href: getPagePath($router, "games.plinko.home") },
    { name: "This game" },
  ]}
>
  <div class="max-w-4xl mx-auto p-4 w-full">
    <PlinkoRoundProgressBar client:load />
  </div>
  <div class="flex-1 max-w-xl mx-auto p-4 w-full">
    {
      game.game_over ? (
        /**
         * If the game is over, show the game over scoreboard
         */
        <div>
          <GameOverScoreboard client:load />
        </div>
      ) : (
        /**
         * If the game is not over, show the game
         */
        <div
          class="w-full mx-auto"
          style={`max-width: ${plinkoSettings.canvasWidth}px;`}
        >
          <PlinkoScoreboard client:load />
          <div class="relative bg-blue-900">
            <canvas
              class="matterCanvas relative"
              width={plinkoSettings.canvasWidth}
              height={plinkoSettings.canvasHeight}
            />
            <canvas
              class="matterCanvasOverlay absolute top-0 left-0 pointer-events-none"
              width={plinkoSettings.canvasWidth}
              height={plinkoSettings.canvasHeight}
            />
          </div>

          <div class="-mt-12 relative flex">
            {/* lottie canvases */}
            {[1, 2, 3, 4, 5, 6, 7].map((i) => (
              <canvas
                class="pocket-lottie-canvas opacity-0"
                style={`width: ${plinkoSettings.canvasWidth / 7}px; height: 50px;`}
                width={plinkoSettings.canvasWidth / 7}
                height={50}
              />
            ))}
          </div>

          <PlinkoPocketValueGrid client:load />
        </div>
      )
    }
  </div>

  <div class="max-w-4xl mx-auto p-4 w-full">
    <div>
      <LeaderboardTable client:load user={user} />
    </div>
  </div>
</GamesLayout>

<!-- dialogs -->
<PlinkoRoundEndedDialog client:load />
<PlinkoRoundWaitingToStartDialog client:load />
<PlinkoGameOverDialog client:load />
