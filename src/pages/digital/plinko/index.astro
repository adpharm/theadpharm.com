---
// import '../styles/global.css';
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Welcome to Plinko</title>

    <style>
      body {
        max-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
      }
    </style>
  </head>

  <body>
    <!-- <button id="play">Play</button> -->
    <script>
      const collisionSound = new Audio("../../src/audio/bubblepop-254773.mp3");
      // collisionSound.play();
      // export the necessary modules
      import Matter, {
        Mouse,
        MouseConstraint,
        Engine,
        Render,
        World,
        Bodies,
        Events,
        Runner,
        Composite,
      } from "matter-js";

      // set up the engine and environment
      const engine = Engine.create();
      const runner = Runner.create();

      const mainDiv: HTMLElement | null = document.querySelector("main");

      if (!mainDiv) {
        throw new Error("mainDiv not found");
      }

      // set up the renderer
      const render = Render.create({
        element: mainDiv,
        engine,
        // set a background slightly lighter than the body's own background
        options: {
          wireframes: false,
          background: "hsl(225, 60%, 20%)",
          width: 800,
          height: 600,
        },
      });

      const mouse = Mouse.create(mainDiv); //Creating the mouse in the world (i.e. Canvas)
      console.log("This is the mouse position: ", mouse.position);
      const { world } = engine;

      // global variables used throughout the canvas
      const width = 400; //800
      const height = 600;
      // number of columns and rows for the grid of pegs
      const columns = 8; //10
      const rows = 10; //20
      // margin to allocate buckets underneath the grid
      const bottomMargin = 150;
      const topMargin = 50;
      // padding to include make space for two rectangles at either side of the canvas
      const padding = width / columns / 2;

      //Setting limit on the number of Plinkos to play with.
      let currentPlinkosCount = 0;
      const maxPlinkosCount = 50;

      // function fabricating a plinko, as a circle included atop the canvas
      const makePlinko = (x: number, y: number) => {
        // utility function returning a random integer between two values for color selection
        const randomBetweenForColor = (min: number, max: number) =>
          Math.floor(Math.random() * (max - min)) + min;
        // Plinko Ball Color
        const fillStyle = `hsl(${randomBetweenForColor(0, 360)}, 90%, 60%)`;

        const r = 10; //ball size

        return Bodies.circle(x, y, r, {
          restitution: 0.8, //Restitution is the amount of bounce/elasticness that an object has when it collides with another object.
          render: {
            fillStyle,
          },
          // add a label to later identify the circle in the collision event
          label: "plinko",
        });
      };

      // From Docs: Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
      const mouseConstraint = MouseConstraint.create(engine, {
        mouse,
      });

      // Fake ball at the top to follow the mouse
      let movingPlinkoBall: Matter.Body;
      // mouseConstraint Mousemove event
      Matter.Events.on(mouseConstraint, "mousemove", (event) => {
        if (movingPlinkoBall) {
          Matter.Body.setPosition(movingPlinkoBall, {
            x: mouse.position.x,
            y: 20,
          });
        } else {
          movingPlinkoBall = makePlinko(mouse.position.x, 20);
          movingPlinkoBall.render.fillStyle = "#808080";

          movingPlinkoBall.isStatic = true;
          Composite.add(world, movingPlinkoBall);
        }
      });

      // mouseConstraint mouseUp event
      Matter.Events.on(mouseConstraint, "mouseup", (event) => {
        console.log("Mouse is moving", mouse.position);

        if (currentPlinkosCount >= maxPlinkosCount) {
          window.alert(
            "Maximum number of plinkos reached, please refresh to play again!"
          );
          return;
        }

        movingPlinkoBall.isStatic = true;
        movingPlinkoBall.render.fillStyle = "#808080";

        const plinkoBall = makePlinko(mouse.position.x, 40);
        Composite.add(world, plinkoBall);

        currentPlinkosCount++;
      });

      // function fabricating a peg, as a white circle with a static position
      // accepting as input the coordinates of the circle's center
      const makePeg = (x: number, y: number) => {
        const r = 5;

        return Bodies.circle(x, y, r, {
          isStatic: true,
          render: { fillStyle: "white" },
          // add a label to later identify the circle in the collision event
          label: "peg",
        });
      };

      // function fabricating a bucket, as a white taller-than-wider rectangle positioned at the bottom of the canvas
      const makeBucket = (x: number) => {
        const w = 5;
        const h = 80;
        const y = height - h / 2;

        return Bodies.rectangle(x, y, w, h, {
          isStatic: true,
          render: {
            fillStyle: "white",
          },
        });
      };

      // PLINKO's elements
      // to prevent the plinkos from bouncing off the canvas's scope, include rectangle elements at the bottom and sides of the element
      const contourSize = 50;
      const contourBottom = Bodies.rectangle(
        width / 2,
        height + contourSize / 2,
        width,
        contourSize,
        {
          isStatic: true,
        }
      );

      // use the padding to create the left and right walls as white tall and thin rectangles
      // the idea is to have them pick up the color of the plinkos coming into contact with the shape
      const contourLeft = Bodies.rectangle(0, 0, padding / 2, height * 2, {
        isStatic: true,
        render: {
          fillStyle: "white",
        },
      });
      const contourRight = Bodies.rectangle(width, 0, padding / 2, height * 2, {
        isStatic: true,
        render: {
          fillStyle: "white",
        },
      });

      const contours = [contourBottom, contourLeft, contourRight];

      // plinko
      // an array of plinkos; the idea is to populate with the world immediately with a set number of plinkos
      // const plinkos = Array.from({ length: initialPlinkos }, () =>
      //   makePlinko()
      // );

      // pegs
      // array of columns and rows; the idea is to have pegs ranging the width and height of the canvas
      // use the padding to reduce the horizontal space allocated to the pegs
      const columnSize = (width - padding * 2) / columns;
      const rowSize = (height - bottomMargin) / rows;

      const grid = Array.from({ length: rows }, (_, row) => {
        const cols = row % 2 === 0 ? columns : columns - 1;
        const dx = cols !== columns ? columnSize / 2 : 0;
        return Array.from({ length: cols }, (_, column) => {
          const x = padding + columnSize * column + columnSize / 2 + dx;
          const y = rowSize * row + rowSize / 2 + topMargin;
          return makePeg(x, y);
        });
      });

      // since grid refers to a 2d array, flatten the items to a one-dimensional array
      const pegs = grid.reduce((acc, curr) => [...acc, ...curr], []);

      // buckets
      // arrays of buckets in which the plinkos would eventually fall
      // as many buckets as the number of columns, to make use of the left and right wall for the outer edges
      const buckets = Array.from({ length: columns }, (_, column) => {
        const x = columnSize * column + columnSize;
        return makeBucket(x);
      });

      // UNTIL HERE, WE CREATED THE OBJECTS THAT WILL BE IN THE GAME (peg, ball, walls, buckets), AND GENERATED THEIR CORRECT NUMBERS.

      // Now we create the world for the game by adding the objects into the world.
      World.add(world, [...contours, ...pegs, ...buckets]); //ceating the world without plinkos. They come out when I click on the button

      // function adding a single plinko, used following a mouse press and at an interval
      // function addPlinko() {
      //   const plinko = makePlinko(width / 2, height / 2);
      //   console.log("Plinko has been added", plinko);
      //   World.add(world, plinko);
      //   // Engine.update(engine);
      // }

      // following a collision event retrieve the label of the two bodies
      // if one is a plinko, consider its color and apply it to the other body
      function handleCollision(event: { pairs: any }) {
        const { pairs } = event;

        pairs.forEach((pair: { bodyA: any; bodyB: any }) => {
          const { bodyA, bodyB } = pair;
          const { label: labelA } = bodyA;
          const { label: labelB } = bodyB;

          // ! change the color only if one of the two body is a plinko
          if (labelA !== labelB) {
            if (labelA === "plinko") {
              const { fillStyle } = bodyA.render;
              bodyB.render.fillStyle = fillStyle;
              collisionSound.play();
            }
            if (labelB === "plinko") {
              const { fillStyle } = bodyB.render;
              bodyA.render.fillStyle = fillStyle;
              collisionSound.play();
            }
          }
        });
      }
      Events.on(engine, "collisionStart", handleCollision);

      // run the engine
      Runner.run(runner, engine); //We have eto create and run the runner so that the engine start playing the annimation.
      // run the renderer
      Render.run(render);
    </script>

    <main class="">
      <!-- <canvas class="fixed inset-0 w-screen h-screen"></canvas> -->
    </main>
  </body>
</html>
