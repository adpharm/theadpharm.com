---
import { actions } from "astro:actions";
import Auth from "@/layouts/Auth.astro";
import Layout from "@/layouts/Layout.astro";
import { Button } from "@/components/ui/button";
---

<script>
  const collisionSound = new Audio("../../src/audio/bubblepop-254773.mp3");
  // collisionSound.play();
  // export the necessary modules
  import {
    Mouse,
    MouseConstraint,
    Engine,
    Render,
    World,
    Body,
    Bodies,
    Events,
    Runner,
    Composite,
    type ICollisionCallback,
  } from "matter-js";

  // set up the engine and environment
  const engine = Engine.create();
  const runner = Runner.create();

  const matterCanvas: HTMLCanvasElement | null =
    document.querySelector(".matterCanvas");

  if (!matterCanvas) {
    throw new Error("matterCanvas not found");
  }

  // set up the renderer
  const render = Render.create({
    canvas: matterCanvas,
    engine,
    // set a background slightly lighter than the body's own background
    options: {
      wireframes: false,
      background: "hsl(225, 60%, 20%)",
      width: 400,
      height: 600,
    },
  });

  const mouse = Mouse.create(matterCanvas); //Creating the mouse in the world (i.e. Canvas)
  console.log("This is the mouse position: ", mouse.position);
  const { world } = engine;

  // global variables used throughout the canvas
  const width = 400; //800
  const height = 600;
  // number of columns and rows for the grid of pegs
  const columns = 8; //10
  const rows = 10; //20
  // margin to allocate buckets underneath the grid
  const bottomMargin = 150;
  const topMargin = 50;
  // padding to include make space for two rectangles at either side of the canvas
  const padding = width / columns / 2;

  //Setting limit on the number of Plinkos to play with.
  let currentPlinkosCount = 0;
  const maxPlinkosCount = 50;

  // function fabricating a plinko, as a circle included atop the canvas
  const makePlinko = (
    x: number,
    y: number,
    size: number,
    customImage: string
  ) => {
    // utility function returning a random integer between two values for color selection
    const randomBetweenForColor = (min: number, max: number) =>
      Math.floor(Math.random() * (max - min)) + min;
    // Plinko Ball Color
    const fillStyle = `hsl(${randomBetweenForColor(0, 360)}, 90%, 60%)`;

    const r = size; //ball size

    if (customImage === "hand") {
      return Bodies.rectangle(x, y, size * 2, size * 2, {
        restitution: 0.8,
        render: {
          sprite: {
            texture: "../../src/images/hand.png",
            xScale: 1.0,
            yScale: 1.0,
          },
        },
        label: "hand",
      });
    }
    return Bodies.circle(x, y, r, {
      restitution: 0.8, //Restitution is the amount of bounce/elasticness that an object has when it collides with another object.
      render: {
        fillStyle,
      },
      // add a label to later identify the circle in the collision event
      label: "plinko",
    });
  };

  // From Docs: Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse,
  });

  // Fake ball at the top to follow the mouse
  let movingPlinkoBall: Matter.Body;
  // mouseConstraint Mousemove event
  Events.on(mouseConstraint, "mousemove", (event) => {
    if (movingPlinkoBall) {
      Body.setPosition(movingPlinkoBall, {
        x: mouse.position.x,
        y: 20,
      });
    } else {
      movingPlinkoBall = makePlinko(mouse.position.x, 20, 20, "hand");

      movingPlinkoBall.isStatic = true;
      Composite.add(world, movingPlinkoBall);
    }
  });

  // mouseConstraint mouseUp event
  Events.on(mouseConstraint, "mouseup", (event) => {
    console.log("Mouse is moving", mouse.position);

    if (currentPlinkosCount >= maxPlinkosCount) {
      window.alert(
        "Maximum number of plinkos reached, please refresh to play again!"
      );
      return;
    }

    movingPlinkoBall.isStatic = true;
    movingPlinkoBall.render.fillStyle = "#808080";

    const plinkoBall = makePlinko(mouse.position.x, 40, 10, "ball");
    Composite.add(world, plinkoBall);

    currentPlinkosCount++;
  });

  // function fabricating a peg, as a white circle with a static position
  // accepting as input the coordinates of the circle's center
  const makePeg = (x: number, y: number) => {
    const r = 5;

    return Bodies.circle(x, y, r, {
      isStatic: true,
      render: { fillStyle: "white" },
      // add a label to later identify the circle in the collision event
      label: "peg",
    });
  };

  // function fabricating a bucket, as a white taller-than-wider rectangle positioned at the bottom of the canvas
  const makeBucket = (x: number) => {
    const w = 5;
    const h = 80;
    const y = height - h / 2;

    return Bodies.rectangle(x, y, w, h, {
      isStatic: true,
      render: {
        fillStyle: "white",
      },
    });
  };

  // PLINKO's elements
  // to prevent the plinkos from bouncing off the canvas's scope, include rectangle elements at the bottom and sides of the element
  // const contourSize = 50;
  // const contourBottom = Bodies.rectangle(
  //   width / 2,
  //   height + contourSize / 2,
  //   width,
  //   contourSize,
  //   {
  //     isStatic: true,
  //   }
  // );

  // use the padding to create the left and right walls as white tall and thin rectangles
  // the idea is to have them pick up the color of the plinkos coming into contact with the shape
  // const contourLeft = Bodies.rectangle(0, 0, padding / 2, height * 2, {
  //   isStatic: true,
  //   render: {
  //     fillStyle: "white",
  //   },
  // });
  // const contourRight = Bodies.rectangle(width, 0, padding / 2, height * 2, {
  //   isStatic: true,
  //   render: {
  //     fillStyle: "white",
  //   },
  // });

  let contourLeftTriangles = [];
  let contourRightTriangles = [];

  for (let i = 120; i < height - bottomMargin; i += 50) {
    // const leftTriangle = Bodies.polygon(-38, i, 3, 60, {
    //   isStatic: true,
    //   angle: Math.PI,
    //   render: {
    //     fillStyle: "white",
    //   },
    // });
    const leftTriangle = Bodies.polygon(-38, i, 3, 60, {
      isStatic: true,
      angle: Math.PI,
      render: {
        sprite: {
          texture: "../../src/images/icy.png",
          xScale: 0.36, //This is changing the pyramid's altitude (tip tip to floor)
          yScale: 0.9, //This is making the base wider (so they can touch)
        },
      },
    });
    // const rigttTriangle = Bodies.polygon(width + width / 10, i, 3, 60, {
    //   isStatic: true,
    //   angle: Math.PI,
    //   render: {
    //     fillStyle: "white",
    //   },
    const rigttTriangle = Bodies.polygon(width + width / 10, i, 3, 60, {
      isStatic: true,
      angle: 2*Math.PI,
      render: {
        sprite: {
          texture: "../../src/images/icy.png",
          xScale: 0.19, //This is changing the pyramid's altitude (tip tip to floor)
          yScale: 0.5, //This is making the base wider (so they can touch)
        },
      },
    });

    contourLeftTriangles.push(leftTriangle);
    contourRightTriangles.push(rigttTriangle);
  }

  World.add(world, [...contourLeftTriangles, ...contourRightTriangles]);

  // const contourLeftTriangles = Bodies.polygon(10, 123, 3, 20, {
  //   isStatic: true,
  //   angle: Math.PI / 3,
  //   render: {
  //     fillStyle: "white",
  //   },
  // });

  // const contours = [contourLeftTriangles, contourRightTriangles];

  // plinko
  // an array of plinkos; the idea is to populate with the world immediately with a set number of plinkos
  // const plinkos = Array.from({ length: initialPlinkos }, () =>
  //   makePlinko()
  // );

  // pegs
  // array of columns and rows; the idea is to have pegs ranging the width and height of the canvas
  // use the padding to reduce the horizontal space allocated to the pegs
  const columnSize = (width - padding * 2) / columns;
  const rowSize = (height - bottomMargin) / rows;

  const grid = Array.from({ length: rows }, (_, row) => {
    const cols = row % 2 === 0 ? columns : columns - 1;
    const dx = cols !== columns ? columnSize / 2 : 0;
    return Array.from({ length: cols }, (_, column) => {
      const x = padding + columnSize * column + columnSize / 2 + dx;
      const y = rowSize * row + rowSize / 2 + topMargin;
      return makePeg(x, y);
    });
  });

  // since grid refers to a 2d array, flatten the items to a one-dimensional array
  const pegs = grid.reduce((acc, curr) => [...acc, ...curr], []);

  // buckets
  // arrays of buckets in which the plinkos would eventually fall
  // as many buckets as the number of columns, to make use of the left and right wall for the outer edges
  const buckets = Array.from({ length: columns }, (_, column) => {
    const x = columnSize * column + columnSize;
    return makeBucket(x);
  });

  // UNTIL HERE, WE CREATED THE OBJECTS THAT WILL BE IN THE GAME (peg, ball, walls, buckets), AND GENERATED THEIR CORRECT NUMBERS.

  // Now we create the world for the game by adding the objects into the world.
  World.add(world, [...contourLeftTriangles, ...pegs, ...buckets]); //ceating the world without plinkos. They come out when I click on the button

  // function adding a single plinko, used following a mouse press and at an interval
  // function addPlinko() {
  //   const plinko = makePlinko(width / 2, height / 2);
  //   console.log("Plinko has been added", plinko);
  //   World.add(world, plinko);
  //   // Engine.update(engine);
  // }

  // following a collision event retrieve the label of the two bodies
  // if one is a plinko, consider its color and apply it to the other body
  const handleCollision: ICollisionCallback = (event) => {
    const { pairs } = event;

    pairs.forEach((pair: { bodyA: any; bodyB: any }) => {
      const { bodyA, bodyB } = pair;
      const { label: labelA } = bodyA;
      const { label: labelB } = bodyB;

      // ! change the color only if one of the two body is a plinko
      if (labelA !== labelB) {
        if (labelA === "plinko") {
          const { fillStyle } = bodyA.render;
          bodyB.render.fillStyle = fillStyle;
          collisionSound.play();
        }
        if (labelB === "plinko") {
          const { fillStyle } = bodyB.render;
          bodyA.render.fillStyle = fillStyle;
          collisionSound.play();
        }
      }
    });
  };
  Events.on(engine, "collisionStart", handleCollision);

  // run the engine
  Runner.run(runner, engine); //We have eto create and run the runner so that the engine start playing the annimation.
  // run the renderer
  Render.run(render);
</script>

<Layout title="Let's play Christmas Plinko! by The Adpharm">
  <Auth>
    <main class="flex flex-col min-h-screen">
      <div class="max-w-7xl mx-auto pt-32">
        <h1>Plinko!</h1>

        <Button type="button" id="plinko.new"> New game </Button>

        <div class="matterContainer h-full w-full bg-red-100">
          <canvas class="matterCanvas"></canvas>
        </div>
      </div>
    </main>
  </Auth>
</Layout>

<script>
  import { actions } from "astro:actions";

  const newGameButton = document.getElementById("plinko.new");
  newGameButton?.addEventListener("click", async () => {
    const { data, error } = await actions.newPlinko({});
    if (error) {
      console.error("Error creating new game", error);
      return;
    }

    console.log("New game created", data);
  });
</script>
